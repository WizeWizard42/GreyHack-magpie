// Made by Merlin Newcomb in 2024

////////////////////////////////////////////////////
// Abstract classes and type extensions
////////////////////////////////////////////////////

//LinQ lib functionality for greyscript
//By MachaCeleste 20240205
map.first = function(key, value)
    for each in self.indexes
        if self[each][key] == value then return self[each]
    end for
end function
map.where = function(key, value)
    ret = {}
    for each in self.indexes
        if self[each][key] == value then ret.push(self[each])
    end for
    return ret
end function
map.wherenot = function(key, value)
    ret = {}
    for each in self.indexes
        if self[each][key] != value then ret.push(self[each])
    end for
    return ret
end function
map.hasMethod = function(method)
    ref = self
    if ref.hasIndex(method) then return true
    while ref.hasIndex("__isa")
        ref = ref["__isa"]
        if ref.hasIndex(method) then return true
    end while
    return false
end function
list.first = function(key, value)
    for each in self
        if typeof(each) == "string" then
            if key == "is" and each == value then return each
            if key == "contains" and each.is_match(value) then return each
            if key == "len" and each.len == value then return each
        else if typeof(each) == "file" then
            if key == "name" and each.name == value then return each
            if key == "namehas" and each.name.is_match(value) then ret.push(each)
            if key == "path" and each.path == value then return each
            if key == "permissions" and each.permissions == value then return each
            if key == "has_permission" then
                v = value.values
                c = ""
                for p in v
                    if each.has_permission(p) then c = c + p
                end for
                if c == value then return each
            end if
            if key == "size" and each.size == value then return each
        else if typeof(each) == "port" then
            if key == "port_number" and each.port_number == value then return each
            if key == "is_closed" and each.is_closed == value then return each
            if key == "get_lan_ip" and each.get_lan_ip == value then return each
        else if typeof(each) == "map" then
            if each[key] == value then return each
        end if
    end for
end function
list.where = function(key, value)
    ret = []
    for each in self
        if typeof(each) == "string" then
            if key == "is" and each == value then ret.push(each)
            if key == "contains" and each.is_match(value) then ret.push(each)
            if key == "len" and each.len == value then ret.push(each)
        else if typeof(each) == "file" then
            if key == "name" and each.name == value then ret.push(each)
            if key == "namehas" and each.name.is_match(value) then ret.push(each)
            if key == "path" and each.path == value then ret.push(each)
            if key == "permissions" and each.permissions == value then ret.push(each)
            if key == "has_permission" then
                v = value.values
                c = ""
                for p in v
                    if each.has_permission(p) then c = c + p
                end for
                if c == value then ret.push(each)
            end if
            if key == "size" and each.size == value then ret.push(each)
        else if typeof(each) == "port" then
            if key == "port_number" and each.port_number == value then ret.push(each)
            if key == "is_closed" and each.is_closed == value then ret.push(each)
            if key == "get_lan_ip" and each.get_lan_ip == value then ret.push(each)
        else if typeof(each) == "map" then
            if each[key] == value then ret.push(each)
        end if
    end for
    return ret
end function
list.wherenot = function(key, value)
    ret = []
    for each in self
        if typeof(each) == "string" then
            if key == "is" and each != value then ret.push(each)
            if key == "contains" and not each.is_match(value) then ret.push(each)
            if key == "len" and each.len != value then ret.push(each)
        else if typeof(each) == "file" then
            if key == "name" and each.name != value then ret.push(each)
            if key == "namehas" and each.name.is_match(value) then ret.push(each)
            if key == "path" and each.path != value then ret.push(each)
            if key == "permissions" and each.permissions != value then ret.push(each)
            if key == "has_permission" then
                v = value.values
                c = ""
                for p in v
                    if each.has_permission(p) then c = c + p
                end for
                if c != value then ret.push(each)
            end if
            if key == "size" and each.size != value then ret.push(each)
        else if typeof(each) == "port" then
            if key == "port_number" and each.port_number != value then ret.push(each)
            if key == "is_closed" and each.is_closed != value then ret.push(each)
            if key == "get_lan_ip" and each.get_lan_ip != value then ret.push(each)
        else if typeof(each) == "map" then
            if each[key] != value then ret.push(each)
        end if
    end for
    return ret
end function
string.regex_escape = function
    result = self
    for x in "+*?^$.[]{}()|/"
        result = result.replace("\"+x, "\"+x)
    end for
    return result
end function

//Simple string color lib functionality for greyscript
// By MachaCeleste 20240305
string.color = function(hexc)
    return "<color=" + hexc + ">" + self + "</color>"
end function

// Miniclick by Merlin Newcomb 2024

MiniClick = {}

// Initialize the commands collection
MiniClick.commands = {}

// CommandBuilder "Class"
CommandBuilder = function(name, description)
    obj = {}
    obj.name = name
    obj.description = description
    obj.options = {}
    obj.arguments = []
    
    obj.add_option = function(name, description, default = false, short_name = null)
        option_data = {
            "name": name,
            "description": description,
            "default": default,
            "short_name": short_name,
        }
        self.options[name] = option_data
        if short_name != null then
            self.options[short_name] = option_data // Allow -<short_name> as alias
        end if
        return self // Enable method chaining
    end function

    obj.add_argument = function(name, description, is_rest = false)
        self.arguments.push({
            "name": name,
            "description": description,
            "is_rest": is_rest,
        })
        return self
    end function

    obj.set_function = function(func)
        self.func = @func
        return self
    end function

    obj.build = function()
        if MiniClick.commands.hasIndex(self.name) then
            print("Warning: Overwriting existing command '" + self.name + "'")
        end if
        MiniClick.commands[self.name] = {
            "name": self.name,
            "description": self.description,
            "options": self.options,
            "arguments": self.arguments,
            "is_alias": false,
            "func": self["func"],
        }
    end function

    return obj
end function

// MiniClick Namespace Methods
MiniClick.create_command = function(name, description)
    return CommandBuilder(name, description)
end function

// Parsing Arguments and Options
MiniClick.parse_args = function(command, args)
    parsed = {}
    arg_index = 0
    i = 0

    handle_option = function(option_name, is_short)
        if not command.options.hasIndex(option_name) then
            print("Unknown option: " + option_name)
            return null
        end if
        option = command.options[option_name]
        if typeof(option.default) == "number" and option.default == false then
            parsed[option_name] = true
            return 1
        else
            if i + 1 >= args.len then
                print("Option " + (is_short and "-" or "--") + option_name + " requires a value")
                return null
            end if
            parsed[option_name] = args[i + 1]
            return 2
        end if
    end function

    while i < args.len
        arg = args[i]
        if arg[:2] == "--" then
            num_consumed = handle_option(arg[2:], false)
            if num_consumed == null then return null
            i = i + num_consumed
        else if arg[:1] == "-" then
            short_name = arg[1:]
            if not command.options.hasIndex(short_name) then
                print("Unknown option: " + short_name)
                return null
            end if
            long_name = command.options[short_name].name
            num_consumed = handle_option(long_name, true)
            if num_consumed == null then return null
            i = i + num_consumed
        else
            if arg_index >= command.arguments.len then
                print("Too many arguments")
                return null
            end if
            arg_def = command.arguments[arg_index]
            arg_name = arg_def.name
            if arg_def.is_rest then
                parsed[arg_name] = args[i:]
                arg_index = arg_index + 1
                break
            else
                parsed[arg_name] = arg
                arg_index = arg_index + 1
                i = i + 1
            end if
        end if
    end while

    for option_name in command.options.indexes
        if not parsed.hasIndex(option_name) then
            parsed[option_name] = command.options[option_name].default
        end if
    end for

    if arg_index < command.arguments.len then
        print("Not enough arguments")
        return null
    end if

    return parsed
end function

// Generating Help Text
MiniClick.generate_help = function(command_name = null)
    if command_name == null then
        help_text = "Available commands:\n"
        for name in MiniClick.commands.indexes
            command = MiniClick.commands[name]
            help_text = help_text + name + ": " + command.description + "\n"
        end for
        help_text = help_text + "\nUse 'command --help' for more information on a specific command."
    else
        if not MiniClick.commands.hasIndex(command_name) then
            return "Unknown command: " + command_name
        end if
        command = MiniClick.commands[command_name]
        help_text = command_name + ": " + command.description + "\n\nArguments:\n"
        for arg in command.arguments
            help_text = help_text + "  " + arg.name + ": " + arg.description + "\n"
        end for

        help_text = help_text + "\nOptions:\n"
        for option_name in command.options.indexes
            if option_name.len == 1 then continue // Skip short options
            
            option = command.options[option_name]
            help_text = help_text + "  --" + option.name
            if option.short_name != null then
                help_text = help_text + " (-" + option.short_name + ")"
            end if
            help_text = help_text + ": " + option.description
            if option.default != null then
                help_text = help_text + " (default: " + option.default + ")"
            end if
            help_text = help_text + "\n"
        end for
    end if
    return help_text
end function

// Running Commands
MiniClick.run = function(args)
    command_name = args[0]
    if not MiniClick.commands.hasIndex(command_name) then
        print("Unknown command: " + command_name)
        return
    end if

    command = MiniClick.commands[command_name]
    if args.len > 1 and args[1] == "--help" then
        print(MiniClick.generate_help(command_name))
        return
    end if

    parsed_args = MiniClick.parse_args(command, args[1:])
    if parsed_args == null then return

    if command["func"] == null then
        print("Error: No function defined for command '" + command_name + "'")
        return
    end if

    result = command.func(parsed_args)
    if result != null then
        return result
    end if
end function

////////////////////////////////////////////////////
// Core classes
////////////////////////////////////////////////////

// Uncomment to enable unit tests
//#include testing/test_harness.src;

StateManager = {}
StateManager.classID = "StateManager"

StateManager.cob = @get_custom_object // Persistent storage for the state manager

StateManager.init = function()
    if not self.cob.hasIndex("focused_object") then 
        self.first_layer()
        return
    end if

    self.cob.layer = self.cob.layer + 1
    self.cob["relative_object"] = self.cob["focused_object"]

    MiniClick.run("put " + self.cob["home_path"] + "/librshell.so " + current_path)
    MiniClick.run("put " + self.cob["home_path"] + "/metaxploit.so " + current_path)

    self.cob["remote_metax"] = include_lib(current_path + "/metaxploit.so")
end function

StateManager.first_layer = function()
    self.cob["aptclient"] = include_lib(current_path + "/aptclient.so")
    if self.cob["aptclient"] == null then exit("aptclient.so needs to be in the same directory as the script!")

    self.cob["aptclient"].update()

    if self.cob["aptclient"].check_upgrade(current_path + "/librshell.so") then
        self.cob["aptclient"].install("librshell.so", current_path)
    end if

    if self.cob["aptclient"].check_upgrade(current_path + "/metaxploit.so") then
        self.cob["aptclient"].install("metaxploit.so", current_path)
    end if

    self.cob["home_metax"] = include_lib(current_path + "/metaxploit.so")
    self.cob["remote_metax"] = include_lib(current_path + "/metaxploit.so")

    self.cob["exploit_store"] = {}  // Structure: {"libname": {"version": {"address": {"string": ["root/user/guest", "shell/computer/file"], "string": ["root/user/guest", "shell/computer/file"]}, ...}}}

    self.cob["remote_rlib"] = null // Only sets once reverse shell is manually set

    self.cob["home_path"] = current_path

    self.cob.layer = 0

    self.cob["partial_object"] = {}
    self.cob["stored_objects"] = []
    self.cob["plugin_stores"] = {}

    self.set_object(get_shell)
    self.cob["focused_object"].info.user = active_user
    self.cob["home_object"] = self.cob["focused_object"]
    self.cob["relative_object"] = self.cob["focused_object"]
end function

StateManager.set_object = function(object)    
    type = typeof(object)

    if type == "number" then return type
    if type == "null" then return "unknown"

    if type == "shell" then
        self.cob["focused_object"] = {
            "uid": md5(str(rnd))[:6],
            "file": object.host_computer.File("/"),
            "computer": object.host_computer,
            "shell": object,
            "info": {
                "user": "unknown",
                "domain": object.host_computer.get_name,
                "pub_ip": object.host_computer.public_ip,
                "local_ip": object.host_computer.local_ip,
            },
        }
        self.cob["stored_objects"].push(self.cob["focused_object"]) 
    end if

    if type == "computer" then
        self.cob["focused_object"] = {
            "uid": md5(str(rnd))[:6],
            "file": object.File("/"),
            "computer": object,
            "shell": null,
            "info": {
                "user": "unknown",
                "domain": object.get_name,
                "pub_ip": object.public_ip,
                "local_ip": object.local_ip,
            },
        }
        self.cob["stored_objects"].push(self.cob["focused_object"])
    end if

    if type == "file" then
        self.cob["focused_object"] = {
            "uid": md5(str(rnd))[:6],
            "file": object,
            "computer": null,
            "shell": null,
            "info": {
                "user": "unknown",
                "domain": "unknown",
                "pub_ip": "unknown",
                "local_ip": "unknown",
            },
        }
        self.cob["stored_objects"].push(self.cob["focused_object"])
    end if

    return type
end function

////////////////////////////////////////////////////

StateCommands = {} // CLI commands for interacting with StateManager
StateCommands.classID = "StateCommands"

StateCommands.list_objects = function(args)
    result = ""
    for obj in StateManager.cob["stored_objects"] // Print UID, type, and IP addresses
        key = obj["uid"]
        result = result + key + ":"

        if StateManager.cob["focused_object"]["uid"] == obj["uid"] then result = result + " (focused)"
        if StateManager.cob["relative_object"]["uid"] == obj["uid"] then result = result + " (relative)"
        if StateManager.cob["home_object"]["uid"] == obj["uid"] then result = result + " (home)"

        if obj["shell"] != null then
            result = result + " shell "
        else if obj["computer"] != null then
            result = result + " computer "
        else 
            result = result + " file "
        end if

        result = result + obj.info["local_ip"] + "@" + obj.info["pub_ip"] + char(10)
    end for
    return result
end function

StateCommands.focus_object = function(args)
    uid = args["uid"]

    obj = StateManager.cob["stored_objects"].first("uid", uid)
    if obj != null then
        StateManager.cob["focused_object"] = obj
        return
    end if

    return "Unknown object: " + uid
end function

StateCommands.release_object = function(args)
    uid = args["uid"]
    obj = StateManager.cob["stored_objects"].first("uid", uid)

    if obj == null then
        return "Unknown object: " + uid
    end if

    if StateManager.cob["focused_object"]["uid"] == uid then return "Cannot release focused object."

    index = StateManager.cob["stored_objects"].indexOf(obj)

    confirm = user_input("Are you sure you want to release this object? (y/n): ")
    if confirm != "y" then return

    return StateManager.cob["stored_objects"].remove(index)
end function

MiniClick.create_command("list", "List stored objects").
    set_function(StateCommands["list_objects"]).
    build()

MiniClick.create_command("focus", "Focus on a stored object").
    add_argument("uid", "The UID of the object to focus on").
    set_function(StateCommands["focus_object"]).
    build()

MiniClick.create_command("release", "Release a stored object").
    add_argument("uid", "The UID of the object to release").
    set_function(StateCommands["release_object"]).
    build()

////////////////////////////////////////////////////

UtilityCommands = {}
UtilityCommands.classID = "UtilityCommands"

UtilityCommands.echo = function(args)
    return args["message"].join(" ")
end function

UtilityCommands.clear = function(args)
    clear_screen()
end function

UtilityCommands.help = function(args)
    return MiniClick.generate_help
end function

UtilityCommands.set_alias = function(args)
    alias = args["alias"]
    command = args["command"]

    if MiniClick.commands.hasIndex(alias) then
        return "Alias already exists: " + alias
    end if

    if not MiniClick.commands.hasIndex(command) then
        return "Unknown command: " + command
    end if

    MiniClick.commands[alias] = MiniClick.commands[command]
end function

UtilityCommands.unset_alias = function(args)
    alias = args["alias"]

    if not MiniClick.commands.hasIndex(alias) then
        return "Unknown alias: " + alias
    end if

    if not MiniClick.commands[alias].is_alias then
        return "Not an alias: " + alias
    end if

    MiniClick.commands.remove(alias)
    return "Alias removed: " + alias
end function

MiniClick.create_command("echo", "Print a message").
    add_argument("message", "The message to print", true).
    set_function(UtilityCommands["echo"]).
    build()

MiniClick.create_command("clear", "Clear the screen").
    set_function(UtilityCommands["clear"]).
    build()

MiniClick.create_command("help", "Show help text").
    set_function(UtilityCommands["help"]).
    build()

MiniClick.create_command("alias", "Create a command alias").
    add_argument("alias", "The alias to create").
    add_argument("command", "The command to alias").
    set_function(UtilityCommands["set_alias"]).
    build()

MiniClick.create_command("unalias", "Remove a command alias").
    add_argument("alias", "The alias to remove").
    set_function(UtilityCommands["unset_alias"]).
    build()

////////////////////////////////////////////////////

ExploitManager = {}
ExploitManager.classID = "ExploitManager"

ExploitManager.remote_lib = function(ip, port)
    port = port.to_int
    if typeof(port) != "number" then return "Invalid port: " + port
    return StateManager.cob["remote_metax"].net_use(ip, port).dump_lib
end function

ExploitManager.local_lib = function(path)
    return StateManager.cob["remote_metax"].load(path)
end function

ExploitManager.get_addresses = function(meta_lib)
    return StateManager.cob["remote_metax"].scan(meta_lib)
end function

ExploitManager.parse_address = function(unparsed)
    segments = unparsed.split("Unsafe check: ")[1:]
    
    parsed = []
    for exploit in segments
        match = exploit.matches("<b>\S*<\/b>\.")
        parsed.push(match.values.pull[3:match.len-6])
    end for

    return parsed
end function

ExploitManager.verify_tuple = function(tuple)
    if tuple.len != 2 then return false
    if not (indexOf(["root", "user", "guest", "unknown"], tuple[0]) == null) then return false
    if not (indexOf(["shell", "computer", "file", "number"], tuple[1]) == null) then return false
    return true
end function

ExploitManager.save_exploit = function(libname, libversion, address, string, result_tuple)
    //if not self.verify_tuple(result_tuple) then return "Invalid tuple: " + result_tuple
    
    if not StateManager.cob["exploit_store"].hasIndex(libname) then
        StateManager.cob["exploit_store"][libname] = {}
    end if

    if not StateManager.cob["exploit_store"][libname].hasIndex(libversion) then
        StateManager.cob["exploit_store"][libname][libversion] = {}
    end if

    if not StateManager.cob["exploit_store"][libname][libversion].hasIndex(address) then
        StateManager.cob["exploit_store"][libname][libversion][address] = {}
    end if

    StateManager.cob["exploit_store"][libname][libversion][address][string] = result_tuple
end function

ExploitManager.get_exploits = function(libname, libversion)
    if not StateManager.cob["exploit_store"][libname] then return {}
    if not StateManager.cob["exploit_store"][libname][libversion] then return {}

    return StateManager.cob["exploit_store"][libname][libversion]
end function

// Returns whether the library directory exists, and creates it if it doesn't
ExploitManager.check_libpath = function(libname, libversion)
    c = StateManager.cob["home_object"]["computer"]
    home_path = StateManager.cob["home_path"]

    exploits_path = home_path + "/exploits"
    lib_path = exploits_path + "/" + libname
    version_path = lib_path + "/" + libversion

    // Function to create a directory if it doesn't exist
    check_dir = function(path, name)
        if not c.File(path + "/" + name) then
            c.create_folder(path, name)
            return false
        end if
        return true
    end function

    // Ensure the necessary directories exist
    check_dir(home_path, "exploits")
    check_dir(exploits_path, libname)

    // If version directory doesn't exist (version hasn't been stored), create it and return false
    return check_dir(lib_path, libversion)
end function

ExploitManager.check_exploit = function(libname, libversion, address = null)
    if not StateManager.cob["exploit_store"].hasIndex(libname) then return false
    if not StateManager.cob["exploit_store"][libname].hasIndex(libversion) then return false
    if address != null and not StateManager.cob["exploit_store"][libname][libversion].hasIndex(address) then return false

    return true
end function

ExploitManager.load_exploit = function(libname, libversion)
    self.check_libpath(libname, libversion)

    version_path = StateManager.cob["home_path"] + "/exploits/" + libname + "/" + libversion

    c = StateManager.cob["home_object"]["computer"]
    for file in c.File(version_path).get_files
        address = file.name
        string_exploits = file.get_content.split(char(10))[:-1]

        for exploit in string_exploits
            exploit_data = exploit.split(" ")
            string = exploit_data[0]
            self.save_exploit(libname, libversion, address, string, [exploit_data[1], exploit_data[2]])
        end for
    end for
end function

ExploitManager.store_exploits = function(libname, libversion)
    if not StateManager.cob["exploit_store"].hasIndex(libname) then return
    if not StateManager.cob["exploit_store"][libname].hasIndex(libversion) then return

    c = StateManager.cob["home_object"]["computer"]
    self.check_libpath(libname, libversion)

    version_path = StateManager.cob["home_path"] + "/exploits/" + libname + "/" + libversion

    // Iterate over addresses and write exploit data
    for address in StateManager.cob["exploit_store"][libname][libversion].indexes
        address_path = version_path + "/" + address
        if not c.File(address_path) then
            c.touch(version_path, address)
        end if

        string_exploits = ""
        for string in StateManager.cob["exploit_store"][libname][libversion][address].indexes
            result_tuple = StateManager.cob["exploit_store"][libname][libversion][address][string]
            string_exploits = string_exploits + string + " " + result_tuple[0] + " " + result_tuple[1] + char(10)
        end for

        c.File(address_path).set_content(string_exploits)
    end for
end function

// Show user list of exploits and what they return, then prompt for exploit and focus on it
ExploitManager.prompt_exploit = function(meta_lib, exploits, opt_val = null)
    result = ""
    exploit_list = []
    for address in exploits.indexes
        result = result + address + char(10)
        for string in exploits[address].indexes
            exploit_list.push([address, string])
            result = result + "  " + exploit_list.len + ": " + string + " -> " +
            exploits[address][string][0] + " " +
            exploits[address][string][1] + char(10)
        end for
    end for
    result = result + char(10)

    while true
        print(result)
        choice = user_input("Select an exploit (e to exit): ")
        if choice == "e" then return
        if typeof(choice.to_int) == "number" then
            choice = choice.to_int
            if choice < 1 or choice > exploit_list.len then
                print("Invalid choice: " + choice)
                continue
            end if
            exploit = exploit_list[choice - 1]
            type = StateManager.set_object(meta_lib.overflow(exploit[0], exploit[1], opt_val))
            if type != "null" and type != "unknown" then
                ExploitManager.save_exploit(meta_lib.lib_name, meta_lib.version, exploit[0], exploit[1], ["unknown", type])
            end if
            break
        else
            print("Invalid choice: " + choice)
        end if
    end while
end function

////////////////////////////////////////////////////

ExploitCommands = {}
ExploitCommands.classID = "ExploitCommands"

ExploitCommands.shotgun_port = function(args)
    ip = args["ip"]
    port = args["port"]
    opt_val = args["opt_val"]

    if typeof(port.to_int) != "number" then return "Invalid port: " + port

    if port.to_int == 0 then 
        local_ip = get_router(ip).local_ip
    else
        local_ip = get_router(ip).device_ports.first("port_number", port.to_int).get_lan_ip
    end if

    meta_lib = ExploitManager.remote_lib(ip, port)
    if typeof(meta_lib) == "string" then return meta_lib

    // Check if the library is already stored
    if not ExploitManager.check_exploit(meta_lib.lib_name, meta_lib.version) then
        addresses = ExploitManager.get_addresses(meta_lib)
    else
        addresses = StateManager.cob["exploit_store"][meta_lib.lib_name][meta_lib.version].indexes
    end if
    
    for address in addresses
        if not ExploitManager.check_exploit(meta_lib.lib_name, meta_lib.version, address) then
            unparsed = StateManager.cob["remote_metax"].scan_address(meta_lib, address)
            strings = ExploitManager.parse_address(unparsed)
        else
            strings = StateManager.cob["exploit_store"][meta_lib.lib_name][meta_lib.version][address].indexes
        end if

        for string in strings
            object = meta_lib.overflow(address, string, opt_val)
            type = StateManager.set_object(object)

            if type != "number" and type != "unknown" then
                StateManager.cob["focused_object"]["info"]["pub_ip"] = ip
                StateManager.cob["focused_object"]["info"]["local_ip"] = local_ip
            end if
            ExploitManager.save_exploit(meta_lib.lib_name, meta_lib.version, address, string, ["unknown", type])
        end for
    end for
end function

ExploitCommands.target_port = function(args)
    ip = args["ip"]
    port = args["port"]
    opt_val = args["opt_val"]

    if typeof(port.to_int) != "number" then return "Invalid port: " + port

    if port.to_int == 0 then 
        local_ip = get_router(ip).local_ip
    else
        local_ip = get_router(ip).device_ports.first("port_number", port.to_int).get_lan_ip
    end if

    meta_lib = ExploitManager.remote_lib(ip, port)
    libname = meta_lib.lib_name
    libversion = meta_lib.version

    if typeof(meta_lib) == "string" then return meta_lib

    // Check if the library is already stored
    if ExploitManager.check_libpath(libname, libversion) then
        ExploitManager.load_exploit(libname, libversion)
    else
        confirm = user_input("Library not stored. Would you like to shotgun it? (y/n): ")
        if confirm == "y" then
            return ExploitCommands.shotgun_port(args)
        end if
        return "Not attacking."
    end if

    // Get exploits from store, then prompt user to select one
    exploits = ExploitManager.get_exploits(libname, libversion)
    ExploitManager.prompt_exploit(meta_lib, exploits, opt_val)
end function

MiniClick.create_command("shotgun", "Shotgun a port for exploits").
    add_argument("ip", "The IP address to target").
    add_argument("port", "The port to target").
    add_option("opt_val", "The value to pass to the exploit", "192.168.0.1", "o").
    set_function(ExploitCommands["shotgun_port"]).
    build()

MiniClick.create_command("target", "Target a port for exploits").
    add_argument("ip", "The IP address to target").
    add_argument("port", "The port to target").
    add_option("opt_val", "The value to pass to the exploit", "192.168.0.1", "o").
    set_function(ExploitCommands["target_port"]).
    build()

////////////////////////////////////////////////////

FileCommands = {}
FileCommands.classID = "FileCommands"

FileCommands.read_file = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]

    file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    if file == null then
        return "File not found: " + filename
    end if
    return file.get_content
end function

FileCommands.write_file = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]
    content = args["content"].join(" ")

    file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    if file == null then
        return "File not found: " + filename
    end if
    result = file.set_content(content)
    if result == true then
        return "File written: " + filename
    end if
    return "Error writing file: " + result
end function

FileCommands.list_files = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    if StateManager.cob["focused_object"]["file"].is_folder == false then
        return "File is not a folder."
    end if
    folders = StateManager.cob["focused_object"]["file"].get_folders
    if folders == null then
        return "cwd has been deleted. Good luck!"
    end if
    files = StateManager.cob["focused_object"]["file"].get_files
    if files == null then
        return "cwd has been deleted. Good luck!"
    end if

    objects = folders + files
    objects.insert(0, StateManager.cob["focused_object"]["file"])

    result = ""
    for obj in objects
        result = result + obj.permissions + " " + obj.owner + " " + obj.group + " " + obj.size + " " + obj.path + char(10)
    end for

    return format_columns(result)
end function

FileCommands.change_dir = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    path = args["path"].trim.split("/")

    temp_file = StateManager.cob["focused_object"]["file"]
    if path[0] == "" then
        while temp_file.parent != null
            temp_file = temp_file.parent
        end while

        path = path[1:]
    end if

    for step in path
        if step == "" then continue
        if step == ".." then
            if temp_file.parent != null then
                temp_file = temp_file.parent
            end if
        else if step == "." then
            continue
        else
            temp_file = temp_file.get_folders.first("name", step)
            if temp_file == null then
                return "Folder not found: " + step
            end if
        end if
    end for

    StateManager.cob["focused_object"]["file"] = temp_file
end function

FileCommands.delete_file = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]

    file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    if file == null then
        return "File not found: " + filename
    end if
    result = file.delete
    if result != "" then
        return "Error deleting file: " + result
    end if
    return "File deleted: " + filename
end function

FileCommands.delete_dir = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    dirname = args["dirname"]

    file = StateManager.cob["focused_object"]["file"].get_folders.first("name", dirname)
    if file == null then
        return "Folder not found: " + dirname
    end if
    result = file.delete
    if result != "" then
        return "Error deleting folder: " + result
    end if
    return "Folder deleted: " + dirname
end function

FileCommands.change_perms = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]
    permissions = args["permissions"]
    recursive = args["recursive"]

    if typeof(permissions.to_int) != "number" then
        return "Invalid permissions: " + permissions
    end if

    if filename == "." then
        file = StateManager.cob["focused_object"]["file"]
    else
        file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    end if

    if file == null then
        return "File not found: " + filename
    end if

    // First, change all permissions to 000.
    result = file.chmod("u-rwx", recursive)
    if result != "" then return "Error changing permissions: " + result
    file.chmod("g-rwx", recursive)
    file.chmod("o-rwx", recursive)

    // Then, convert octal to rwx.
    user_octal = permissions[0].to_int
    group_octal = permissions[1].to_int
    other_octal = permissions[2].to_int

    // Ternary operators don't exist in this language, so we have to do it the long way.
    user_perms = "u+"
    if bitAnd(user_octal, 4) then user_perms = user_perms + "r"
    if bitAnd(user_octal, 2) then user_perms = user_perms + "w"
    if bitAnd(user_octal, 1) then user_perms = user_perms + "x"

    group_perms = "g+"
    if bitAnd(group_octal, 4) then group_perms = group_perms + "r"
    if bitAnd(group_octal, 2) then group_perms = group_perms + "w"
    if bitAnd(group_octal, 1) then group_perms = group_perms + "x"

    other_perms = "o+"
    if bitAnd(other_octal, 4) then other_perms = other_perms + "r"
    if bitAnd(other_octal, 2) then other_perms = other_perms + "w"
    if bitAnd(other_octal, 1) then other_perms = other_perms + "x"

    // Finally, apply the new permissions.
    file.chmod(user_perms, recursive)
    file.chmod(group_perms, recursive)
    file.chmod(other_perms, recursive)

    return "Permissions changed."
end function

FileCommands.change_group = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]
    group = args["group"]
    recursive = args["recursive"]

    file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    if file == null then
        return "File not found: " + filename
    end if

    result = file.set_group(group, recursive)
    if result != "" then
        return "Error changing group: " + result
    end if
end function

FileCommands.change_owner = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]
    owner = args["owner"]
    recursive = args["recursive"]

    file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    if file == null then
        return "File not found: " + filename
    end if

    result = file.set_owner(owner, recursive)
    if result != "" then
        return "Error changing owner: " + result
    end if
end function

FileCommands.copy_file = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]
    destination = args["destination"]
    newname = args["newname"]

    file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    if file == null then
        return "File not found: " + filename
    end if

    result = file.copy(destination, newname)
    if typeof(result) == "string" then
        return "Error copying file: " + result
    end if
end function

FileCommands.move_file = function(args)
    if StateManager.cob["focused_object"]["file"] == null then
        return "File object not set."
    end if
    filename = args["filename"]
    destination = args["destination"]
    newname = args["newname"]

    file = StateManager.cob["focused_object"]["file"].get_files.first("name", filename)
    if file == null then
        return "File not found: " + filename
    end if

    result = file.move(destination, newname)
    if typeof(result) == "string" then
        return "Error moving file: " + result
    end if
end function

MiniClick.create_command("cat", "Read the contents of a file").
    add_argument("filename", "The name of the file to read").
    set_function(FileCommands["read_file"]).
    build()

MiniClick.create_command("write", "Write to a file").
    add_argument("filename", "The name of the file to write to").
    add_argument("content", "The content to write", true).
    set_function(FileCommands["write_file"]).
    build()

MiniClick.create_command("ls", "List files in the current directory").
    set_function(FileCommands["list_files"]).
    build()

MiniClick.create_command("cd", "Change the current directory").
    add_argument("path", "The path to change to").
    set_function(FileCommands["change_dir"]).
    build()

MiniClick.create_command("rm", "Delete a file").
    add_argument("filename", "The name of the file to delete").
    set_function(FileCommands["delete_file"]).
    build()

MiniClick.create_command("rmdir", "Delete a folder").
    add_argument("dirname", "The name of the folder to delete").
    set_function(FileCommands["delete_dir"]).
    build()

MiniClick.create_command("chmod", "Change file permissions").
    add_argument("filename", "The name of the file to change permissions for").
    add_argument("permissions", "The new permissions (octal, not rwx)").
    add_option("recursive", "Apply changes recursively", false, "r").
    set_function(FileCommands["change_perms"]).
    build()

MiniClick.create_command("chgrp", "Change file group").
    add_argument("filename", "The name of the file to change group for").
    add_argument("group", "The new group").
    add_option("recursive", "Apply changes recursively", false, "r").
    set_function(FileCommands["change_group"]).
    build()

MiniClick.create_command("chown", "Change file owner").
    add_argument("filename", "The name of the file to change owner for").
    add_argument("owner", "The new owner").
    add_option("recursive", "Apply changes recursively", false, "r").
    set_function(FileCommands["change_owner"]).build()

MiniClick.create_command("cp", "Copy a file").
    add_argument("filename", "The name of the file to copy").
    add_argument("destination", "The destination folder").
    add_argument("newname", "The new name of the file").
    set_function(FileCommands["copy_file"]).
    build()

MiniClick.create_command("mv", "Move a file").
    add_argument("filename", "The name of the file to move").
    add_argument("destination", "The destination folder").
    add_argument("newname", "The new name of the file").
    set_function(FileCommands["move_file"]).
    build()

////////////////////////////////////////////////////

ComputerCommands = {}
ComputerCommands.classID = "ComputerCommands"

ComputerCommands.view_procs = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    return format_columns(StateManager.cob["focused_object"]["computer"].show_procs)
end function

ComputerCommands.kill_proc = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    pid = args["pid"].to_int
    if typeof(pid) != "number" then return "Invalid PID: " + args["pid"]
    
    return StateManager.cob["focused_object"]["computer"].close_program(pid)
end function

ComputerCommands.add_user = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    username = args["username"]
    password = args["password"]

    return StateManager.cob["focused_object"]["computer"].create_user(username, password)
end function

ComputerCommands.remove_user = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    username = args["username"]
    remove_home = args["remove_home"]

    return StateManager.cob["focused_object"]["computer"].delete_user(username, remove_home)
end function

ComputerCommands.add_group = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    username = args["username"]
    groupname = args["groupname"]

    return StateManager.cob["focused_object"]["computer"].create_group(username, groupname)
end function

ComputerCommands.remove_group = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    username = args["username"]
    groupname = args["groupname"]

    return StateManager.cob["focused_object"]["computer"].delete_group(username, groupname)
end function

ComputerCommands.create_file = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    path = args["path"]
    filename = args["filename"]

    return StateManager.cob["focused_object"]["computer"].touch(path, filename)
end function

ComputerCommands.create_folder = function(args)
    if StateManager.cob["focused_object"]["computer"] == null then
        return "Computer object not set."
    end if
    path = args["path"]
    foldername = args["foldername"]

    return StateManager.cob["focused_object"]["computer"].create_folder(path, foldername)
end function

MiniClick.create_command("ps", "View running processes").
    set_function(ComputerCommands["view_procs"]).
    build()

MiniClick.create_command("kill", "Kill a running process").
    add_argument("pid", "The PID of the process to kill").
    set_function(ComputerCommands["kill_proc"]).
    build()

MiniClick.create_command("adduser", "Add a new user").
    add_argument("username", "The username of the new user").
    add_argument("password", "The password of the new user").
    set_function(ComputerCommands["add_user"]).
    build()

MiniClick.create_command("deluser", "Delete a user").
    add_argument("username", "The user to delete").
    add_option("remove_home", "Remove the user's home directory", false, "r").
    set_function(ComputerCommands["remove_user"]).
    build()

MiniClick.create_command("addgroup", "Add a new group").
    add_argument("username", "The user to add to the group").
    add_argument("groupname", "The name of the new group").
    set_function(ComputerCommands["add_group"]).
    build()

MiniClick.create_command("delgroup", "Delete a group").
    add_argument("username", "The user to remove from the group").
    add_argument("groupname", "The name of the group to delete").
    set_function(ComputerCommands["remove_group"]).
    build()

MiniClick.create_command("touch", "Create a new file").
    add_argument("path", "The path to create the file in").
    add_argument("filename", "The name of the new file").
    set_function(ComputerCommands["create_file"]).
    build()

MiniClick.create_command("mkdir", "Create a new folder").
    add_argument("path", "The path to create the folder in").
    add_argument("foldername", "The name of the new folder").
    set_function(ComputerCommands["create_folder"]).
    build()

////////////////////////////////////////////////////

ShellCommands = {}
ShellCommands.classID = "ShellCommands"

ShellCommands.drop_shell = function(args)
    if StateManager.cob["focused_object"]["shell"] == null then
        return "Shell object not set."
    end if

    confirm = user_input("Are you absolutely sure you want to drop to a shell? (y/n): ")
    if confirm == "y" then
        print("Dropping to shell...")
        return start_terminal(StateManager.cob["focused_object"]["shell"])
    end if
end function

ShellCommands.build_file = function(args)
    if StateManager.cob["focused_object"]["shell"] == null then
        return "Shell object not set."
    end if
    source_path = args["source_path"]
    destination_path = args["destination_path"]
    can_import = args["can_import"]

    return build(StateManager.cob["focused_object"]["shell"], source_path, destination_path, can_import)
end function

ShellCommands.get_file = function(args)
    if StateManager.cob["focused_object"]["shell"] == null then
        return "Shell object not set."
    end if
    source_path = args["source_path"]
    destination_path = args["destination_path"]
    to_relative = args["to_relative"]

    if to_relative then
        return scp(StateManager.cob["focused_object"]["shell"], source_path, destination_path, get_shell)
    end if

    return scp(StateManager.cob["focused_object"]["shell"], source_path, destination_path, StateManager.home_shell)
end function

ShellCommands.put_file = function(args)
    if StateManager.cob["focused_object"]["shell"] == null then
        return "Shell object not set."
    end if
    source_path = args["source_path"]
    destination_path = args["destination_path"]
    from_relative = args["from_relative"]

    if from_relative then
        return scp(get_shell, destination_path, source_path, StateManager.cob["focused_object"]["shell"])
    end if

    return scp(StateManager.home_shell, destination_path, source_path, StateManager.cob["focused_object"]["shell"])
end function

ShellCommands.run_command = function(args)
    if StateManager.cob["focused_object"]["shell"] == null then
        return "Shell object not set."
    end if
    program = args["program"]
    params = args["params"].join(" ")

    confirm = user_input("Are you sure you want to run an external program? You will lose your current context. (y/n): ")
    if confirm == "y" then
        return launch(StateManager.cob["focused_object"]["shell"], program, params)
    end if
end function

ShellCommands.try_ping = function(args)
    if StateManager.cob["focused_object"]["shell"] == null then
        return "Shell object not set."
    end if
    ip = args["ip"]

    is_pingable = ping(StateManager.cob["focused_object"]["shell"], ip)

    if typeof(is_pingable) == "string" then return is_pingable
    if is_pingable then return "Ping successful."

    return "Ping failed."
end function

MiniClick.create_command("shell", "Drop to a shell").
    set_function(ShellCommands["drop_shell"]).
    build()

MiniClick.create_command("build", "Build a file").
    add_argument("source_path", "The path to the source file").
    add_argument("destination_path", "The path to the destination folder").
    add_option("can_import", "Allow the file to be imported", false, "i").
    set_function(ShellCommands["build_file"]).
    build()

MiniClick.create_command("get", "Get a file").
    add_argument("source_path", "The path to the source file").
    add_argument("destination_path", "The path to the destination folder").
    add_option("to_relative", "Put the file in your current relative shell", false, "r").
    set_function(ShellCommands["get_file"]).
    build()

MiniClick.create_command("put", "Put a file").
    add_argument("source_path", "The path to the source file").
    add_argument("destination_path", "The path to the destination folder").
    add_option("from_relative", "Get the file from your current relative shell", false, "r").
    set_function(ShellCommands["put_file"]).
    build()

MiniClick.create_command("launch", "Run an external program").
    add_argument("program", "The program to run").
    add_argument("params", "The parameters to pass to the program", true).
    set_function(ShellCommands["run_command"]).
    build()

MiniClick.create_command("ping", "Ping an IP address").
    add_argument("ip", "The IP address to ping").
    set_function(ShellCommands["try_ping"]).
    build()

////////////////////////////////////////////////////
// Basic testing usage
////////////////////////////////////////////////////

// Uncomment to enable File tests
//#include testing/file_tests.src;

StateManager.init()

// This whole thing will be rewritten, but works for now
while true
    prompt_text = StateManager.cob["focused_object"].info.user + 
    "@" + StateManager.cob["focused_object"].info.pub_ip + 
    ": " + StateManager.cob["focused_object"]["file"].path + "# "

    command = user_input(prompt_text).trim
    if command == "exit" then
        for lib in StateManager.cob["exploit_store"].indexes
            for version in StateManager.cob["exploit_store"][lib].indexes
                if not ExploitManager.check_libpath(lib, version) then
                    ExploitManager.store_exploits(lib, version)
                end if
            end for
        end for
        break
    end if
    command = command.split(" ")
    for i in command
        if i == "" then
            command.remove(i)
        end if
    end for

    result = MiniClick.run(command)
    if result != null then
        print(result)
    end if
end while
